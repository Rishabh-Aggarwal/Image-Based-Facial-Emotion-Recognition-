# -*- coding: utf-8 -*-
"""FDS_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/181PmbSpO_HypFpFdSrTDOA_WpT4Nmpvz
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
# %matplotlib inline

emo_dict = {0: 'Angry', 1: 'Disgust', 2: 'Fear', 3: 'Happy', 4: 'Sad', 5: 'Surprise', 6: 'Neutral'}

df = pd.read_csv('/content/drive/My Drive/fer2013.csv')

df.shape

df.head()

len(df['pixels'][0].split())

df['emotion'].value_counts()

# Convert pixels into pd.Series of numpy arrays
df['pixels'] = df['pixels'].apply(lambda x: np.array(x.split(), dtype=np.float))

df['pixels']

def plot_first_100_faces(df):
    plt.figure(figsize=(15, 15))
    for i in range(0, 100):
        plt.subplot(10, 10, i+1)
        data = df['pixels'][i].reshape((48, 48))
        plt.imshow(data, cmap='gray')
        plt.xticks([])
        plt.yticks([])
        plt.ylabel('hi')
        plt.axis('off')

plot_first_100_faces(df)

from scipy.sparse.linalg import eigs

def make_image_vector(image_list, new_size):
    D = np.empty([len(image_list), new_size])
    i = 0
    for image in image_list:
        D[i, :] = image
        i += 1
    return D

def avgfaces_by_emotion(df):
    avgfaces = []
    
    for emotion in sorted(df['emotion'].unique()):
        sub_df = df[df['emotion']==emotion]
        
        avg_pixels = np.mean(sub_df['pixels'].values)

        avgfaces.append((avg_pixels, emotion))
        
    return avgfaces

def eigenfaces_by_emotion(df, k=1):
    eigenfaces = []
    
    for emotion in sorted(df['emotion'].unique()):
        sub_df = df[df['emotion']==emotion]
        
        pixels = list(sub_df['pixels'].values)                                   
        D = make_image_vector(pixels, 48*48)
        A = np.dot(D.T, D)
        
        # Find k largest magnitude (LM) eigenvectors
        vals, vecs = eigs(A, k, which='LM')
        
        eigenfaces.extend([(vec.reshape(48, 48).astype(float), emotion) for vec in vecs.T])
        
    return eigenfaces

avgfaces = avgfaces_by_emotion(df)

eigenfaces = eigenfaces_by_emotion(df, 1)

# Plot eigenfaces and show emotion label
def plot_face_and_emotion(plot_nrow, plot_ncol, face_list):
    fig, axes = plt.subplots(plot_nrow, plot_ncol, figsize=(15, 15))
    for i, (face, emotion) in enumerate(face_list):
        ax = axes.ravel()[i]
        ax.imshow(face.reshape(48, 48), cmap='gray')
        # Turn off tick labels
        ax.set_xlabel(emo_dict[emotion])
        ax.set_yticklabels([])
        ax.set_xticklabels([])

plot_face_and_emotion(7, 1, avgfaces)

plot_face_and_emotion(7, 1, eigenfaces)

"""PCA"""

from sklearn.decomposition import PCA
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
from sklearn import neighbors
from sklearn.neighbors import (KNeighborsClassifier,NeighborhoodComponentsAnalysis)
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import itertools

X = make_image_vector(df['pixels'], 48*48)

y = df['emotion'].map(emo_dict).values
class_names = ['Angry','Disgust', 'Fear', 'Happy', 'Sad', 'Surprise',  'Neutral']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.5)

p = Pipeline([
        ('scale', StandardScaler()),
        ('pca', PCA(n_components=10)),
        ('classifier', neighbors.KNeighborsClassifier(n_neighbors=1))
        ])

p.fit(X_train, y_train)

p.score(X, y)

y_pred = p.predict(X)
print(classification_report(y, y_pred))
print (confusion_matrix(y, y_pred))
print("Accuracy: ", accuracy_score(y, y_pred))
print("Normalise Confusion Matrix")
print (confusion_matrix(y, y_pred,normalize='true'))